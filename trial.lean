import Mathlib.Data.Real.Basic

/-!
# Lean 4 の主要構文の解説

## 1. `theorem` - 定理の定義
`theorem` は名前付きの定理を定義します。定義した定理は後で他の証明で再利用できます。

構文: `theorem 名前 (引数) : 命題 := 証明`
- 名前: 定理に付けられる識別子（例: `add_comm_real`）
- 引数: 定理で使用する変数とその型（例: `(a b : ℝ)`）
- 命題: 証明すべき内容（例: `a + b = b + a`）
- 証明: 命題を証明する式やタクティク
-/

-- 実数の加法の交換法則
-- 任意の実数 a, b に対して a + b = b + a が成り立つ
theorem add_comm_real (a b : ℝ) : a + b = b + a :=
  add_comm a b
-- ↑ この定理は `add_comm_real` という名前で保存され、他の場所で使用可能
--
-- 【重要なポイント】
-- `add_comm` は型クラス `AddCommSemigroup` に対して定義された一般的な定理です。
-- `ℝ` は `AddCommSemigroup` のインスタンスなので、`add_comm a b` は型推論により
-- `ℝ` に対して適用されます。
--
-- `add_comm_real` は実質的に `add_comm` を実数型に特化したラッパーとして定義しています。
-- これは「名前を付け直している」というより、以下の利点があります：
-- 1. 型が明示的に `ℝ` に限定されている（型推論が不要で明確）
-- 2. 実数に特化した定理として文書化できる
-- 3. 後で参照可能な名前が付けられている（`add_comm_real` として呼び出せる）
--
-- しかし、証明の内容自体は `add_comm` をそのまま使用しているので、
-- 実質的には同じ内容を証明しています。

/-!
## ラッパー（Wrapper）とは

**ラッパー**とは、既存の機能やコードを包み込んで（wrap）、より使いやすくしたり、
特定の用途に特化させたりする仕組みのことです。

### 一般的なラッパーの例：

1. **関数のラッパー**
   ```python
   # 既存の関数
   def complex_function(x, y, z, ...):
       # 複雑な処理
       return result

   # ラッパー関数（使いやすくする）
   def simple_wrapper(x, y):
       return complex_function(x, y, default_z, ...)
   ```

2. **APIのラッパー**
   - 既存のAPIを呼び出すが、エラーハンドリングやログを追加
   - 複雑なAPIを簡単なインターフェースで提供

3. **型のラッパー**
   - 既存の型を新しい型で包んで、特定の意味を持たせる

### Leanにおけるラッパー定理：

`add_comm_real` は `add_comm` のラッパー定理です：

- **既存の機能**: `add_comm` （一般的な交換法則の定理）
- **ラッパー**: `add_comm_real` （実数型に特化した定理）
- **利点**:
  - 型が明確（`ℝ` に限定）
  - 実数専用の定理として文書化できる
  - 名前で意図が明確になる

### 比喩的な説明：

ラッパーは「包装紙」のようなものです：
- 中身（`add_comm`）は同じ
- でも包装紙（`add_comm_real`）があることで：
  - 何が入っているか分かりやすい
  - 特定の用途（実数）に特化していることが明確
  - 使いやすい形になっている
-/

/-!
## 2. `example` - 名前なしの例・証明
`example` は名前を付けずに命題を証明します。練習やテスト用に使います。
`theorem` と違い、後で参照できません。

構文: `example : 命題 := 証明` または `example (引数) : 命題 := 証明`
-/

-- より明示的な証明（Mathlib4のadd_commを使用）
example (a b : ℝ) : a + b = b + a := by
  exact add_comm a b
-- ↑ `by` キーワードでタクティクモードに入る

/-!
## 3. `exact` - タクティク
`exact` は、現在のゴール（証明すべき命題）と完全に一致する項を提供するタクティクです。
`by` キーワードの後に使います。

- `exact 項`: ゴールと型が完全に一致する項を直接与える
- 例: `exact add_comm a b` は `a + b = b + a` というゴールに対して
  `add_comm a b` という型が `a + b = b + a` の項を提供する
-/

-- または、simpタクティクを使用
example (a b : ℝ) : a + b = b + a := by
  simp [add_comm]
-- ↑ `simp` は自動的に等式を簡約するタクティク

/-!
## 4. `simp` - 簡約タクティク
`simp` は自動的に式を簡約（simplify）する強力なタクティクです。

- `simp`: デフォルトの簡約ルールを使用
- `simp [ルール1, ルール2, ...]`: 指定したルールを追加で使用
- `simp [add_comm]`: `add_comm` のルールを使って式を簡約
- 等式の両辺を同じ形に変形して、自動的に証明を完成させる

`simp` は `exact` より柔軟で、複数のステップを自動的に処理できます。
-/

-- 具体的な数値での例
example : (2 : ℝ) + 3 = 3 + 2 :=
  add_comm (2 : ℝ) 3
-- ↑ `by` なしでも直接証明項を書ける（タクティクモードを使わない方法）

-- より一般的な形式（型推論によりℝと推論される）
example (a b : ℝ) : a + b = b + a :=
  add_comm a b
-- ↑ タクティクモードを使わず、直接証明項を書く方法
